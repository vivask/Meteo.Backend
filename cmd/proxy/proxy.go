package main

import (
	"context"
	"fmt"
	"io"
	"meteo/cmd/proxy/internal/service"
	"meteo/internal/client"
	"meteo/internal/config"
	"meteo/internal/leader"
	"meteo/internal/log"
	repo "meteo/internal/repo/proxy"
	"os"
	"time"

	"gorm.io/gorm"
)

type Proxy struct {
	lead   *leader.Leader
	cli    *client.Client
	server *service.Server
	repo   repo.ProxyService
	ctx    context.Context
	cancel context.CancelFunc
}

func New(db *gorm.DB) (*Proxy, error) {
	leader := leader.New(config.Default.App.Master, config.Default.Client.Local, config.Default.Client.Remote)
	client, err := client.New(leader)
	if err != nil {
		return nil, fmt.Errorf("client create error: %w", err)
	}
	return &Proxy{
		lead:   leader,
		cli:    client,
		server: service.NewServer(),
		repo:   repo.NewProxyService(db),
	}, nil
}

func (p *Proxy) Start() (err error) {

	err = p.configLocalResolver()
	if err != nil {
		return fmt.Errorf("can't configure resolver: %w", err)
	}

	p.server.SetZones(service.LoadZones(p.repo))
	p.server.SetBlackList(service.LoadFromFile(config.Default.App.Dir))
	p.server.SetUnlocker(service.LoadUnlocker(p.repo, p.cli))

	p.ctx, p.cancel = context.WithCancel(context.Background())
	timeout := time.After(1 * time.Second)
	fErr := make(chan error, 1)
	go func(fErr chan error) {
		fErr <- p.server.Run(p.ctx)
	}(fErr)

	select {
	case e := <-fErr:
		if e != nil {
			return fmt.Errorf("proxy server failed to start, error: %w", e)
		}
	case <-timeout:
	}

	go p.verifyServerState()

	/*if p.lead.IsMaster() {
		go func() {
			time.Sleep(5 * time.Second)
			p.repo.ReplaceAllExt()
		}()
	}*/

	log.Debugf("Proxy server success started")

	return nil
}

func (p *Proxy) configLocalResolver() error {
	if len(config.Default.Proxy.Resolvers) == 0 {
		return fmt.Errorf("undefined local resolver")
	}

	if config.Default.Proxy.Resolvers[0] == "no" {
		return nil
	}

	const fName = "/etc/resolv.conf"
	file, err := os.OpenFile(fName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return fmt.Errorf("can't open file: %s, error: %w", fName, err)
	}
	defer file.Close()

	io.WriteString(file, "#Generated by meteo daemon\n")

	for _, resolver := range config.Default.Proxy.Resolvers {
		nameserver := fmt.Sprintf("nameserver %s\n", resolver)
		io.WriteString(file, nameserver)
	}

	return nil
}

func (p *Proxy) verifyServerState() {
	for {
		timer := time.After(p.server.GetTimerVerifyRetry())
		select {
		case <-timer:
			p.server.VerifyState()
		case <-p.ctx.Done():
			return
		}
	}
}
